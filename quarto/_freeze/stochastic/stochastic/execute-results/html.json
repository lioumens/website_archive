{
  "hash": "991c7ad70cfa38ebdf6ebf8bdc4cdd94",
  "result": {
    "markdown": "---\ntitle: \"Stochastic\"\nauthor: \"Michael Liou\"\nformat: html\neditor: visual\nresources: \"vid/*\"\n---\n\n::: {.cell hash='stochastic_cache/html/unnamed-chunk-1_c04304976085b735d0585022fd25dea5'}\n\n:::\n\n\n## Gamblers Ruin\n\nThe random walk we're simulating is a symmetric random walk from some initial location, and calculating the expected hitting time of crossing some upper or lower boundary\n\n\n::: {.cell hash='stochastic_cache/html/unnamed-chunk-2_b112053bbb9f288811fbced274f73217'}\n\n:::\n\n::: {.cell hash='stochastic_cache/html/unnamed-chunk-3_547690ee80e6550caf247d8d5987b65e'}\n\n```{.r .cell-code}\nset.seed(20)\nk <- 10\nrw <- rw_sim(a, b, p, k, return_path = TRUE)\n\nqplot(0:(length(rw) - 1), rw, geom = \"line\", xlab = \"time\", ylab = \"state\", linetype = \"random walk path\") + \n  geom_hline(yintercept = b, color = \"tomato1\") + \n  geom_hline(yintercept = a, color = \"tomato1\") +\n  annotate(\"point\", x = 0, y = 10, size = 2, color = \"lightblue\") +\n  annotate(\"label\", label = \"k - initial state\", x = 3, y = 9, fill = \"lightblue\", size = 2) +\n  annotate(\"point\", x = 44, y = 0, size = 2, color = \"lightblue\") +\n  annotate(\"label\", label = \"T - hitting time\", x = 41, y = 1, fill = \"lightblue\", size = 2) +\n  scale_linetype_manual(values = c(3)) + \n  labs(linetype = \"\",\n       title = \"Hitting Times of Random Walk\") + \n  lims(y = c(a, b)) + \n  theme_minimal() + \n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](stochastic_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nBy theory, for the symmetric random walk, (see Durrett)\n\n$$\n\\begin{aligned}\nE[T|X_0 = k] = (k - a)(b - k)\n\\end{aligned}\n$$\n\n\n::: {.cell hash='stochastic_cache/html/unnamed-chunk-4_727c7cb50e5c47332c8c1246ea4abdf5'}\n\n```{.r .cell-code}\nhitting_times <- replicate(10000,\n                           rw_sim(a,b,p, k))\nmean(hitting_times)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 101.0178\n```\n:::\n:::\n\n\n## Stochastic Processes\n\nA great overview of Differential Equations in R is covered by\n\n-   \"sde\" - stochastic differential equations\n\n-   \"Sim.DiffProc\"- simulate diffusion processes\n\n-   \"ReacTran\" - functions for generating finite differences on a grid\n\n### Wiener Process\n\nThe most basic wiener process takes the form, which describes Brownian motion. This differential equation models 1 dimensional diffusion, and to see this, we can imagine the probability distribution over time. Each of the sample paths are a random walk with gaussian increment with proportional\n\n$$\ndx = dW\n$$\n\n-   $x$ is the position, which is a function of time\n-   $dW$ is the Wiener Noise, gaussian distribution with\n\n\n::: {.cell hash='stochastic_cache/html/unnamed-chunk-5_c8af96190a73fb541f2552082b997685'}\n\n```{.r .cell-code}\nx0 <- 0 # initial position\nt0 <- 0 # initial time\ndt <- .01\nnt <- 100 # how many time steps to take, \ndx <- rnorm(nt, 0, dt) # sample steps\nx <- cumsum(c(x0, dx)) # sample path\n\nrwiener <- function(x0 = 0, t0 = 0, dt = .01, nt = 100) {\n  dx <- rnorm(nt, 0, sqrt(dt)) # sample steps\n  cumsum(c(x0, dx)) # sample path\n}\n\nset.seed(1)\nwiener_paths <- replicate(2000, rwiener())\nwiener_ts <- ts(wiener_paths, start = t0, deltat = dt)\nts.plot(wiener_ts, col = rgb(0,0,0,alpha = .03), ylim = c(-4, 4), main = \"Wiener Sample Paths\")\n```\n\n::: {.cell-output-display}\n![](stochastic_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nInstead of the sample path approach, if we instead think about the probability density of our position as a function of time, we can see that the probability function becomes more diffuse over time. Thus, it's not surprising that we can describe the diffusion with a PDE through the Fokker-Plank Equation.\n\n\n::: {.cell hash='stochastic_cache/html/unnamed-chunk-6_5f82fc1e7c1dc12503f641cce1d7c236'}\n\n```{.r .cell-code}\n# code to create animations\nx <- seq(-3, 3, by = .01)\n# animation of density\nsaveGIF({\n    for (i in 2:100)  {\n      hist(wiener_ts[i,], xlim = c(-3, 3), ylim = c(0, 10),\n           freq = F,\n           breaks = 40,\n           main = paste0(\"Density of Sample Paths, Time = \", i*dt),\n           xlab = \"x\")\n      lines(x, dnorm(x, sd = sqrt(dt * i)), col = \"red\")\n      legend(\"topright\", legend = c(\"theoretical density\"), col = 2, lty = 1, bty = \"n\")\n    }\n}, movie.name = \"test.gif\", loop = T, interval = .01)\n\n# along the sample paths\nsaveGIF({\n    for (i in 2:100)  {\n      ts.plot(wiener_ts, col = rgb(0,0,0,alpha = .03), ylim = c(-4, 4), main = \"Wiener Sample Paths\")\n      abline(v = i * dt, col = \"red\")\n    }\n}, movie.name = \"sample.gif\", loop = T, interval = .01)\n```\n:::\n\n\n::: {layout-ncol=\"2\"}\n![](sample.gif)\n\n![](test.gif)\n:::\n\nThe associated Fokker Plank equation associated with this stochastic differential equation, is simply the heat equation.\n\n$$\n\\frac{\\partial}{\\partial t} P(x, t) =\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}P(x,t)\n$$\n\n-   Initial condition: $P(x, 0) = \\delta(x)$\n-   $\\delta(x)$ is the delta-dirac function, which has infinite mass at 0.\n-   Boundary Condition: $P(a, t) = P(b, t) = 0$\n    -   since our simulation has to occur on some bounded region $[a,b]$, we just set the simulation to have absorbing boundaries.\n\nSolving the PDE with initial value conditions analytically, we find that the solution to this eigenvalue problem is\n\n$$\n\\begin{aligned}\nP(x, t) = \\frac{1}{\\sqrt{2\\pi t}}\\exp \\left(\\frac{x^2}{2t}\\right)\n\\end{aligned}\n$$\n\nWe can also calculate the solution by finite differencing. We can solve the PDE and show that our solutions match the rate given by the SDE formulation of the PDE. We use code from the [vignette of the `ReacTran` R package](https://rdrr.io/rforge/diffEq/f/inst/doc/PDEinR.pdf). `ReacTran` package uses the method of lines for solving PDE's, in which we set up a discretized grid, and solve the ODE as a vector\n\n\n::: {.cell hash='stochastic_cache/html/unnamed-chunk-7_a784d21a2d63f71bffe9b4120b4a36f8'}\n\n```{.r .cell-code}\n# ReacTran uses the\nN <- 601\nxgrid <- setup.grid.1D(x.up = -3, x.down = 3, N = N) # grid of values\nx <- xgrid$x.mid\nD.coeff <- .5 # diffusion coefficient from solving FP\n\n# defines the diffusion (the derivative with respect to time)\n# Since our function has no time dependence, we only need to calculate the derivatives for the next step\nDiffusion <- function (t, Y, parms){\n  tran <- tran.1D(C = Y, C.up = 0, C.down = 0, # dirchlet boundary conditions, set to 0\n                D = D.coeff, dx = xgrid)\n  list(dY = tran$dC)\n}\n\n# Set initial condition of the differential equation, we approximate the \nYini <- c(rep(0, 300), 100, rep(0, 300)) # very tall initial mass\ntt <- seq(t0, dt * nt, dt) #times to simulate\n\n# solve heat equation\nout <- ode.1D(y = Yini, times = tt, func = Diffusion, parms = NULL, dimens = N)\n\n# library(tidyverse)\ncolorBreaks = 10^(seq(-2, 2, length.out = 255)) # different\nplot(raster(t(out[,-1]), xmn =0, xmx = 1, ymn = -3, ymx = 3),\n     asp = NA,\n     breaks = colorBreaks,\n     col = rev(hcl.colors(length(colorBreaks) - 1L, palette = \"Rocket\")), legend = FALSE,\n     xlab = \"time\", ylab = \"x\", interpolate = TRUE)\n```\n\n::: {.cell-output-display}\n![](stochastic_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n### Ornstein-Uhlenbeck Process\n\nAdding a drift term to the stochastic equation, gives the stochastic equation a mean. The negative in front of the drift implies that it will always regress to 0, because it's a function of $x$ (kind of like a spring constant). The $\\theta$ parameter controls how strong the restoring force is.\n\n$$\ndx = -\\theta x\\, dt + \\sigma \\, dW\n$$\n\n-   $x$ is position, which is a function of time.\n-   $dW$ is the wiener process.\n-   $\\theta$ is the rate of return to the mean (0)\n-   Variance of\n\nThe following shows the effect of the parameters $\\theta = 3$ and $\\sigma = .5$ with initial state $x_0 = 5$. We also show the process with a different initial state $x_0 = -3$ to show the restoring effect to the mean.\n\n\n\n\n::: {.cell hash='stochastic_cache/html/unnamed-chunk-9_c7cd1467a31dd045b5ee3a16e7b03f90'}\n\n```{.r .cell-code}\n# OU function\nou_paths <- function(npaths = 1, theta = 3, sigma = .5, x0 = 5, nt = 100, t0 = 0, dt = .01) {\n  sde_path_ou <- function() {\n    x <- vector(mode = \"numeric\", length = nt + 1)\n    x[1] <- x0\n    wiener_noise <- rnorm(nt, sd = sqrt(dt))\n    for (i in 1:nt) {\n      dx <- -theta * x[i] * dt + sigma * wiener_noise[i]\n      x[i+1] <- x[i] + dx\n    }\n    return(x)\n  }\n  ts(replicate(npaths, sde_path_ou()), start = t0, deltat = dt)\n}\n\ntheta <- 3\nsig <- .5\ny0 <- 5\nnt <- 100\ndt <- .01\nt0 <- 0\n\nset.seed(1)\nou_ts <- ou_paths(npaths = 500, theta = theta, sigma = sig, x0 = y0, nt = nt, t0 = t0, dt = dt)\n\nts.plot(ou_ts, col = rgb(0,0,0,alpha = .05)) # plot\n\ntt <- seq(0, 1, .01)\ntheory_mean <- y0*exp(-theta*tt)\ntheory_var <- sig^2 / 2 / theta * (1 - exp(-2 * theta * tt))\n\nlines(tt, theory_mean, col = \"red\")\nlines(tt, theory_mean + 2 * sqrt(theory_var), lty = 2, col = \"red\")\nlines(tt, theory_mean - 2 * sqrt(theory_var), lty = 2, col = \"red\")\nlegend(\"topright\", legend = c(\"mean\", \"\\u00B1 2sd\"), col = 2, lty = 1:2)\n```\n\n::: {.cell-output-display}\n![](stochastic_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nBecause of this restoring property to the mean, a closely related stochastic process is known as the Vasicek model (commonly used to model interest rates), which adds another parameter to control what the mean is.\n\n$$\ndx = \\theta(\\mu - x)\\, dt + \\sigma \\, dW\n$$\n\n-   reduces to the 0 mean OU process when $\\mu = 0$.\n\n-   The long term variance of this model is also\n\n\n\n\n\nThis process is important because it's the continuous time analogue of a discrete time AR1 process.\n\nSimilarly, the associated Fokker-Plank Equation for this SDE is:\n\n$$\n\\begin{aligned}\n\\frac{\\partial P(x, t)}{\\partial t} = -\\mu \\frac{\\partial P(x, t)}{\\partial x} + \\frac{\\sigma^2}{2}\\frac{\\partial^2P(x, t)}{\\partial x^2}\n\\end{aligned}\n$$\n\n\n::: {.cell hash='stochastic_cache/html/unnamed-chunk-11_0046c9d3c3d3ee857e85c60442fef8ce'}\n\n```{.r .cell-code}\n# simulation parameters\nt0 <- 0                       # time start\ndt <- .01                     # time step \ntn <- 1                       # time end\nnt <- tn/dt                   # number of time steps\ntgrid <- seq(t0, nt * dt, dt) # time grid\n\nx0 <- 6                       # space start\nxn <- -2                    # space end\nnx <- 800                     # number of grid points\nxgrid <- setup.grid.1D(x.up = x0, x.down = xn, N = nx) # space grid\nx <- xgrid$x.int\n\nsig <- .5            # Parameters from OU simulation\nmu <- -3             # Parameters from OU simulation  \nD_coef <- sig^2 / 2  # Diffusion function\n\ny0 <- c(rep(0, 100), 100, rep(0, 699))                 # initial condition\n\n# advection-diffusion (method of lines)\nadvec <- function(t, Y, parms) {\n  trans <- tran.1D(C = Y, D = D_coef, v = mu*x, C.up = 0, C.down = 0, dx = xgrid)\n  return(list(dY = trans$dC))\n}\n\n# solve advec/diffusion equation\nout <- ode.1D(y = y0, times = tgrid, func = advec, parms = NULL, dimens = nx)\n\n# plot solution\ncolorBreaks = 10^(seq(-3, 3, length.out = 255)) # different to capture more drift in lower parameters\nplot(raster(t(out[,-1]), xmn = 0, xmx = 1, ymn = xn, ymx = x0),\n     asp = NA,\n     breaks = colorBreaks,\n     col = rev(hcl.colors(length(colorBreaks) - 1L, palette = \"Rocket\")), legend = FALSE,\n     xlab = \"time\", ylab = \"x\", interpolate = TRUE)\n```\n\n::: {.cell-output-display}\n![](stochastic_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# rcOU(n=1, Dt=0.1, x0=1, theta=c(0,2,1))\n```\n:::\n\n\n::: {.callout-note appearance=\"minimal\" icon=\"false\"}\n### ODE for Mean/Variance of OU process\n\nWe can get a First Order ODE characterization of the mean and variance for the Ornstein-Uhlenbeck process.\n\n\n```{=tex}\n\\begin{aligned}\n\\frac{d\\langle x \\rangle}{dt} = -\\theta \\langle x \\rangle \\\\\n\\langle x\\rangle = \\langle x_0 \\rangle e^{-\\theta t}\n\\end{aligned}\n```\n\n$$\n\\frac{dV}{dt} = -2 \\theta V + \\sigma^2\n$$\n\n::: {.callout-note collapse=\"true\" appearance=\"minimal\" icon=\"false\"}\n### Proof\n\n$$\ndx = -\\theta x\\, dt + \\sigma\\, dW\n$$ First we note the expression for the derivative of variance, and calculate the necessary components.\n\n$$\n\\begin{align*}\n\\frac{dV}{dt} &= \\frac{d\\langle x^2\\rangle}{dt} - \\frac{d \\langle x\\rangle^2}{dt} \\\\\n&= \\frac{d\\langle x^2\\rangle}{dt} - 2 \\langle x\\rangle \\frac{d \\langle x\\rangle}{dt}\n\\end{align*}\n$$\n\nHence, we need to evaluate the mean differentials to the second order, from\n\n$$\n\\begin{align}\nd\\langle x\\rangle &= -\\theta \\langle x\\rangle \\, dt\\\\\ndx^2 &= (x + dx)^2 - x^2 \\\\\n&=2x\\,dx + (dx)^2 \\\\\n&= (-2\\theta x^2 + \\sigma^2)\\,dt + \\sigma \\, dW \\\\\nd\\langle x^2\\rangle &= (-2\\theta \\langle x^2\\rangle + \\sigma^2)\\, dt\n\\end{align}\n$$\n\nWe've used that the rules of Ito's calculus, that $dt\\,dW = 0, (dW)^2 = dt, (dt)^2 =0$. Plugging in the values and simplifying gives us the desired result.\n:::\n:::\n\n\n::: {.cell hash='stochastic_cache/html/unnamed-chunk-12_7989fae56d0d8136fda25c07ec50a8ef'}\n\n```{.r .cell-code}\ntheta <- 3\nsig <- .5\n\n# simplest first order ode\nou_mean <- function(t, y, parms) {\n  dy <- -theta * y\n  return(list(dy))\n}\n\n\nx0 <- 5 # initial mean\ntt <- seq(0, 1, by = .01)\nout_mean <- ode(x0, tt, ou_mean, parms = NULL)\n\ncbind(out_mean[,2],\n      5 * exp(-3* tt)) |> head() # matches\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         [,1]     [,2]\n[1,] 5.000000 5.000000\n[2,] 4.852224 4.852228\n[3,] 4.708817 4.708823\n[4,] 4.569653 4.569656\n[5,] 4.434600 4.434602\n[6,] 4.303538 4.303540\n```\n:::\n\n```{.r .cell-code}\n# function coding differential equation \nou_var <- function(t, v, parms) {\n  dv <- -2 * theta * v + sig^2\n  return(list(dv))\n}\n\ny0 <- 0 # initial variance\ntt <- seq(0, 1, by = .01)\n\nout <- ode(y0, tt, ou_var, parms = NULL)\n\ncbind(out[,2],\n      sig^2 / 2 / theta * (1 - exp(-2 * theta * tt))) |> head() # matches!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            [,1]        [,2]\n[1,] 0.000000000 0.000000000\n[2,] 0.002426880 0.002426478\n[3,] 0.004712408 0.004711648\n[4,] 0.006864444 0.006863741\n[5,] 0.008891073 0.008890506\n[6,] 0.010799760 0.010799241\n```\n:::\n:::\n\n\n### General Linear SDE\n\n$$\ndx = -\\gamma x \\, dt + g x\\, dW\n$$\n\n## Reaction Diffusion Equations\n\nThese are non-linear differential equations, and a system of them. We can start describing the reactions of SIR model as sets of nonlinear differential equations. There are a number of famous examples of these, we'll study the Grey-Scott system, then the SIR system, and hopefully we'll see the reaction diffusion nonlinearity around the boundaries of the different stable sets.\n\n### Grey-Scott Model\n\nA really cool web simulation of the phenomena I want to recreate can be found by [Karl Sims, Reaction Diffusion Tutorial](https://www.karlsims.com/rd.html). Luckily, someone else has already implemented a version of this, and we'll just borrow [their code (Fronkonstin)](https://github.com/aschinchon/reaction-diffusion).\n\n![](https://thumbs.gfycat.com/SeveralIncomparableChupacabra-size_restricted.gif){width=\"296\"}\n\nThe Grey-Scott Model describes the following irreversible, reactions of three compound $U, V, P$ and $P$ is an inert product.\n\n$$\n\\begin{align*}\nU + 2V &\\rightarrow 3V \\\\\nV &\\rightarrow P\n\\end{align*}\n$$\n\nWe will use the simulation parameters from @pearsonComplexPatternsSimple1993, in particular, the equations that result from this reaction diffusion is\n\n$$\n\\frac{\\partial U}{\\partial t} = D_u \\nabla^2U - UV^2 + F(1 - U) \\\\\n\\frac{\\partial V}{\\partial t} = D_v \\nabla^2V + UV^2 - (F + k)V\n$$\n\n-   $D_u = 2 \\times 10^{-5}$\n\n-   $D_v = 10^{-5}$\n\n-   periodic boundary condition\n\n-   $F$ and $k$ are known as the feed and kill rates of the reactants. since concentration ranges between 0 and 1, the reaction term in the first equation is positive, and then F controls how much of reactant $U$ is being introduced.\n\n\n\n\n\n\n::: {.cell hash='stochastic_cache/html/unnamed-chunk-15_6cd608d40047ba8981a787f912fc0faa'}\n\n```{.r .cell-code}\ngray_scott <- function(U0 = NULL, V0 = NULL,\n                       feed_rate = 0.0545,\n                       kill_rate = 0.062,\n                       N = 256,\n                       tN = 2000,\n                       D.u = 1,\n                       D.v = .5,\n                       save_frame_freq = 20,\n                       video_file = \"gray_scott.mp4\",\n                       pic_dir = NULL,\n                       init_strategy = c(\"random\"),\n                       seed = 1,\n                       ...) {\n  set.seed(seed)\n  pct <- proc.time()\n  init_strategy <- match.arg(init_strategy)\n  if (missing(U0) | missing(V0)) {\n    #TODO: implement different initialization strategies for different patterns\n    U0 <- matrix(1, nrow = N, ncol = N)\n    V0 <- matrix(0, nrow = N, ncol = N)\n    V0[sample(N^2, ceiling(N^2 / 20))] <- 1 # 10% of cells\n    } else if (!all(c(dim(U0), dim(V0)) == N)) {\n      rlang::abort(\"Initial Matrix must be a grid with dimension N\")\n    }\n  \n  U <- U0\n  V <- V0\n  # 9 point stencil for Laplacian\n  # yuvj420p pix format used: https://superuser.com/questions/1273920/deprecated-pixel-format-used-make-sure-you-did-set-range-correctly\n  L <- matrix(c(0.05, 0.2, 0.05, \n                0.2,  -1, 0.2,\n                0.05, 0.2, 0.05), nrow = 3)\n  \n  \n  if (missing(pic_dir))\n    pic_dir <- tempdir() \n  else \n    pic_dir <- fs::dir_create(fs::path_wd(pic_dir))\n\n  # clean directory  \n  if (length(Sys.glob(fs::path(pic_dir, \"*.jpg\"))) > 0 ) {\n    rlang::abort(sprintf(\"%s not empty, please clean out *.jpg files to prevent overwriting!\", pic_dir))\n  }\n\n  jpeg_file <- fs::path(pic_dir, sprintf(\"plot%06d.jpg\", 0))\n  jpeg(jpeg_file)\n      # setup base plot graphical parameters\n      par(bty = \"n\", oma = rep(0, 4), mar = rep(0, 4))\n      plot(raster(V0),\n           axes = F, bty = \"n\", frame.plot = F,\n           interpolate = F,\n           breaks = hist(V0, breaks = 256, plot = F)$breaks,\n           col = hcl.colors(256,  palette = \"ag_sunset\"),\n           legend = FALSE)\n      \n      dev.off()\n  \n  p <- progressr::progressor(tN / save_frame_freq)\n  for (i in 1:tN) {\n    dU <- D.u * filter2(U, L) - U * V^2 + feed_rate * (1 - U)\n    dV <- D.v * filter2(V, L) + U * V^2 - (feed_rate + kill_rate) * V\n    U <- U + dU\n    V <- V + dV\n    # save frame in temp folder\n    if (i %% save_frame_freq == 0) {\n      p(message = sprintf(\"Timestep: %g\", i))\n      jpeg_file <- fs::path(pic_dir,\n                            sprintf(\"plot%06d.jpg\", i))\n      jpeg(jpeg_file)\n      # setup base plot graphical parameters\n      par(bty = \"n\", oma = rep(0, 4), mar = rep(0, 4))\n      plot(raster(V),\n           axes = F, bty = \"n\", frame.plot = F,\n           interpolate = T,\n           breaks = hist(V, breaks = 256, plot = F)$breaks,\n           col = hcl.colors(256,  palette = \"ag_sunset\"),\n           legend = FALSE)\n      dev.off()\n    }\n  }\n  \n  # create video directory\n  fs::dir_create(fs::path_wd(fs::path_dir(video_file)))\n  \n  #TODO: check if ffmpeg available on system?\n  ffmpeg_cmd <- sprintf('ffmpeg -y -f image2 -pattern_type glob -i \"%s/*.jpg\" -framerate 60 -c:v libx264 -crf 20 -filter:v \"format=yuvj420p\" %s', pic_dir, fs::path_wd(video_file))\n  # run ffmpeg command\n  system(ffmpeg_cmd)\n  cat(paste0(\"Running command: \", ffmpeg_cmd, \"\\n\"))\n  proc.time() - pct # elapsed wall time\n}\n# relative to this script (when running commands in notebook)\nwith_progress(\n  gray_scott(video_file = \"vid/gray_scott.mp4\", pic_dir = \"gray_pic\"), handlers = handlers(\"progress\")) # for text updates\n```\n:::\n\n\n<figure class=\"figure\">\n\n<video loop autoplay >\n\n<source src=\"vid/gray_scott.mp4\" type=\"video/mp4\">\n\n</video>\n\n<figcaption>Gray Scott Reaction Diffusion, $f=.0545, k=.062$</figcaption>\n\n</figure>\n\n\n\n\n\n### SIR Diffusion\n\n\n::: {.cell hash='stochastic_cache/html/unnamed-chunk-17_46c0d52b022de8b7863ccc4f4592c7ae'}\n\n:::\n\n\n\n\nhere's we're trying to upsample the values that come out of the\n\nThe SIR image has a slightly different quality to it in that the lines around the image are thinner\n\n<figure class=\"figure\">\n\n<video loop autoplay >\n\n<source src=\"vid/sir_diffusion.mp4\" type=\"video/mp4\">\n\n</video>\n\n<figcaption>SIR Reaction Diffusion, $f=.0545, k=.062$</figcaption>\n\n</figure>\n\n### SIS system\n\nI'm curious if the SIS system without vital dynamics will show any interesting patterns. We know there must be an absorbing state, but this system can also reach an endemic state based on the reproduction number. If we add diffusion into the system we should get interesting results, at the very least some cool videos.\n\n### Brusselator\n\n### Lorentz Attractor\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}