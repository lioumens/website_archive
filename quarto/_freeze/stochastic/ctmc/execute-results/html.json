{
  "hash": "becea2e1b12cf2943be8ce63d38c9930",
  "result": {
    "markdown": "---\ntitle: \"CTMC\"\nauthor: \"Michael Liou\"\ndate: \"2023-01-14\"\nexecute:\n  cache: true\n---\n\n::: {.cell hash='ctmc_cache/html/unnamed-chunk-1_b0b26df9befed80896bf76d7f5b2a072'}\n\n```{.r .cell-code  code-summary=\"Libraries\"}\nlibrary(adaptivetau)\nlibrary(GillespieSSA)\nlibrary(GillespieSSA2)\nlibrary(tidyverse)\nlibrary(cowplot)\n```\n:::\n\n\n## R Package Overview\n\n### Adaptive Tau\n\nThere are 3 functions featured in in adaptive tau\n\n-   `ssa.exact` - the gillespie algorithm for exact transitions\n\n-   `ssa.adaptivetau` - implements the Cao adaptive tau algorithm in C++\n\n-   `ssa.maketrans` - create transition matrix\n\n\n::: {.cell hash='ctmc_cache/html/unnamed-chunk-2_c81536060c77eff96263504e1184ed1b'}\n\n```{.r .cell-code}\nlvrates <- function(x, params, t) {\n  with(params, {\n    return(c(preygrowth*x[\"prey\"],      ## prey growth rate\n             x[\"prey\"]*x[\"pred\"]*eat,   ## prey death / predator growth rate\n             x[\"pred\"]*preddeath))      ## predator death rate\n  })\n}\nparams=list(preygrowth=10, eat=0.01, preddeath=10);\nr=ssa.exact(c(prey = 1000, pred = 500),\n            matrix(c(1,0, -2,1, 0,-1), nrow=2), lvrates, params, tf=2)\n\nmatplot(r[,\"time\"], r[,c(\"prey\",\"pred\")], type='l', xlab='Time', ylab='Counts')\nlegend(\"topleft\", legend=c(\"prey\", \"predator\"), lty=1:2, col=1:2)\n```\n\n::: {.cell-output-display}\n![](ctmc_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n### GillespieSSA2\n\nGillespieSSA2 is an improvement on the original that runs many times faster for simulation. It is also a method for simulating CTMC.\n\n\n::: {.cell hash='ctmc_cache/html/unnamed-chunk-3_ee0137b886fde96610e3877a824c0f61'}\n\n```{.r .cell-code}\ninitial_state <- c(prey = 1000, predators = 1000)\nparams <- c(c1 = 10, c2 = 0.01, c3 = 10)\nreactions <- list(\n  #        propensity function     effects                       name for reaction\n  reaction(~c1 * prey,             c(prey = +1),                 \"prey_up\"),\n  reaction(~c2 * prey * predators, c(prey = -1, predators = +1), \"predation\"),\n  reaction(~c3 * predators,        c(predators = -1),            \"pred_down\")\n)\n\nout <-\n  ssa(\n    initial_state = initial_state,\n    reactions = reactions,\n    params = params,\n    method = ssa_exact(),\n    final_time = 5,\n    census_interval = .001,\n    verbose = TRUE\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning SSA exact with console output every 1 seconds\nwalltime: 0, sim_time: 0\nSSA finished!\n```\n:::\n\n```{.r .cell-code}\nplot_ssa(out)\n```\n\n::: {.cell-output-display}\n![](ctmc_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n## Exact CMTC Network SIS\n\nThis section recreates the figures from the mieghan paper\n\n\n::: {.cell hash='ctmc_cache/html/unnamed-chunk-4_e6a579e393006b77cc28e60f9dc9cf56'}\n\n```{.r .cell-code}\n# N <- 3\n# create adjacency graph of line graph\nline_adj <- function(N) {\n  toeplitz(c(0, 1, rep(0, N-2)))\n}\n\ncomplete_adj <- function(N) {\n  A <- matrix(1, N, N)\n  diag(A) <- 0\n  A\n}\n\nsis_make_Q <- function(A, delta, beta) {\n  if (nrow(A) > 10) rlang::abort(\"please dont\")\n  N <- nrow(A)\n  num_states <- 2^N\n  states <- matrix(as.integer(intToBits(0:(num_states - 1))), nrow = 32)[N:1,]\n  num_I <- states |> colSums()\n  chr_states <- apply(MARGIN = 2, states, FUN = {\\(x) paste0(x, collapse = \"\")})\n  possible_trans <- which(adist(chr_states) == 1, arr.ind = TRUE)\n  \n  assign_rate <- function(x, delta, beta, num_I){\n    if (num_I[x[1]] > num_I[x[2]]) return(delta)\n    else {\n      threat_node <- which((states[, x[2]] - states[,x[1]]) == 1)\n      (states[,x[1]] %*% A)[threat_node] * beta\n    }\n  }\n  \n  trans_rate <- apply(possible_trans,\n                      MARGIN = 1,\n                      FUN = assign_rate,\n                      delta = delta, beta = beta, num_I = num_I)\n  Q_el <- cbind(possible_trans,\n      trans_rate)\n  Q <- matrix(0, num_states, num_states)\n  Q[Q_el[,1:2 ]] <- Q_el[,3]\n  # set diags\n  diag(Q) <- -rowSums(Q)\n  Q\n}\n\n# Figure 5\n# 4 largest eigenvalues of complete graph\n\n# top 4 eigen values\nQ_top_4 <- function(tau, A) {\n  delta <- 5e-3\n  beta <- tau * delta\n  Q <- sis_make_Q(A, delta, beta)\n  sort(Re(eigen(Q)$values), decreasing = T)[1:4]\n}\n\n# Plot figure -------------------------------------------------------------\n\ntaus <- seq(.01, .5, .02) # parameter\n\nA <- complete_adj(5)\nK5 <- taus |> map(Q_top_4, A = A)\nK5_mat <- do.call(rbind, K5)\nK5_tib <- K5_mat |> as_tibble(.name_repair = ~as.character(1:4)) |> \n  add_column(N= 5, taus = taus, .before = 1)\n\nA <- complete_adj(8)\nK8 <- taus |> map(Q_top_4, A = A)\nK8_mat <- Re(do.call(rbind, K8)) # real values\nK8_tib <- K8_mat |> as_tibble(.name_repair = ~as.character(1:4)) |> \n  add_column(N= 8,taus = taus, .before = 1)\n\nA <- complete_adj(10)\nK10 <- taus |> map(Q_top_4, A = A)\nK10_mat <- do.call(rbind, K10)\nK10_tib <- K10_mat |> as_tibble(.name_repair = ~as.character(1:4)) |> \n  add_column(N= 10, taus = taus, .before = 1)\n\nbind_rows(K5_tib, K8_tib, K10_tib) |> \n  pivot_longer(cols = 3:6, names_to = \"rank\")|> \n  ggplot(aes(x = taus, y = value, group = interaction(N, rank), color = factor(N))) +\n  geom_line() +\n  labs(x = \"Tau\",\n       y = \"Eigenvalue\",\n       color = \"N\") +\n  facet_wrap(~N) +\n  theme_test()\n```\n\n::: {.cell-output-display}\n![](ctmc_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n::: {.cell hash='ctmc_cache/html/unnamed-chunk-5_3afedd69ab9a51ce48af7815a0a1793d'}\n\n```{.r .cell-code}\n# Figure 7\ntaus <- c(0.05, .1, .15, .2, .25, .3, .4, .5, .6, .7, 1, 2)\n\nby_size <- function(N) {\n  A <- line_adj(N)\n  Q_2 <- function(tau) {\n    delta <- 5e-3\n    beta <- delta * tau\n    Q <- sis_make_Q(A, delta, beta)\n    sort(Re(eigen(Q, only.values = TRUE)$values), decreasing = T)[2]\n  }\n  taus |> map_dbl(Q_2)\n}\n\n\nNs <- 2:10\n\nline_2 <- Ns |> map(by_size) |> as_tibble(.name_repair = ~Ns |> as.character())\nspectral_line <- 2:10 |> map_dbl(~1/max(abs(eigen(line_adj(.x))$values))) # spectral radius\n\ng1 <- line_2 |> add_column(tau = taus, .before = 1) |> \n  pivot_longer(cols = -1, names_to = \"N\", values_to = \"L2\") |> \n  ggplot(aes(x = as.integer(N), y = L2, color = tau, group = tau)) +\n  geom_line() + \n  theme(legend.position = \"none\")\n\ng2 <- qplot(x = 2:10, spectral_line, xlab = \"N\", ylab = \"crit. tau\")  + geom_line()\n\nplot_grid(g1, g2, labels = \"auto\")\n```\n\n::: {.cell-output-display}\n![](ctmc_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nCool, we've replicated the two main plots in the papers\n\n\n::: {.cell hash='ctmc_cache/html/unnamed-chunk-6_fb51f8d1631c09451801e1844de1970a'}\n\n```{.r .cell-code}\n# bifurcation on line graphs?\ntaus <- seq(.01, .5, .02) # parameter\n\nA <- line_adj(5)\nL5 <- taus |> map(Q_top_4, A = A)\nL5_mat <- do.call(rbind, L5)\nL5_tib <- L5_mat |> as_tibble(.name_repair = ~as.character(1:4)) |> \n  add_column(N= 5, taus = taus, .before = 1)\n\nA <- line_adj(8)\nL8 <- taus |> map(Q_top_4, A = A)\nL8_mat <- Re(do.call(rbind, L8)) # real values\nL8_tib <- L8_mat |> as_tibble(.name_repair = ~as.character(1:4)) |> \n  add_column(N= 8,taus = taus, .before = 1)\n\nA <- line_adj(10)\nL10 <- taus |> map(Q_top_4, A = A)\nL10_mat <- do.call(rbind, L10)\nL10_tib <- L10_mat |> as_tibble(.name_repair = ~as.character(1:4)) |> \n  add_column(N= 10, taus = taus, .before = 1)\n\nbind_rows(L5_tib, L8_tib, L10_tib) |> \n  pivot_longer(cols = 3:6, names_to = \"rank\")|> \n  ggplot(aes(x = taus, y = value, group = interaction(N, rank), color = factor(N))) +\n  geom_line() +\n  labs(x = \"Tau\",\n       y = \"Eigenvalue\",\n       color = \"N\") +\n  facet_wrap(~N) +\n  theme_test()\n```\n\n::: {.cell-output-display}\n![](ctmc_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nIt doesn't seem like there's anything here, but what about .5 to 2? It seems there's no bifurcating patterns on these graphs because we can already see the top 4 values.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}