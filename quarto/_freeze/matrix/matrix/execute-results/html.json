{
  "hash": "bdc27ecca8372062e7797d92d732630d",
  "result": {
    "markdown": "---\ntitle: \"Matrix Math\"\nauthor: \"Michael Liou\"\nformat: \n  html: \n    page-layout: full\ntoc-depth: 4\nexecute:\n  cache: true\nbibliography: ../references.bib\n---\n\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-2_fdbc90e0b6c7bd4cde8a369bb4c59f3a'}\n\n```{.r .cell-code}\nlibrary(igraph)\nlibrary(Matrix)\nlibrary(spam)\nlibrary(tidyverse)\nlibrary(purrr)\nlibrary(rgraph6)\nlibrary(fs)\nlibrary(forcats)\n\n\n# devtools::install_github(\"lioumens/Lmisc\") # private repo\nlibrary(Lmisc)\n```\n:::\n\n\n## Basic Matrices\n\nLet $j$ be the vector of all 1's, and $J$ be the matrix of all ones.\n\n$$\n\\begin{aligned}\njj' &= J \\\\\nj'x  &= \\sum x \\\\\nj'A  &= \\operatorname{colsums}(A) \\\\\nAj &= \\operatorname{rowsums}(A) \\\\\nJx &= \\begin{bmatrix}\n  \\sum x \\\\\n  \\vdots \\\\\n  \\sum x \\\\\n\\end{bmatrix}\n\\end{aligned}\n$$\n\n## Adjacency Matrix\n\n### Spectral Bounds\n\n#### Simple\n\nAll 3 of these proofs and results can be found in @newmanNetworks2018, section 18.2.3.\n\n1.  Largest Eigenvalue, undirected, unweighted, lower bound by average degree\n\n$$\n\\begin{aligned}\n\\lambda_1(A) \\geq d_{avg}\n\\end{aligned}\n$$\n\nproof: use 1 vector as test vector in courant fischer\n\n2.  Largest Eigenvalue, undirected, unweighted, lower bound by max degree\n\n$$\n\\begin{aligned}\n\\lambda_1(A) \\geq \\sqrt{d_{max}}\n\\end{aligned}\n$$ proof: use \\[sqrt(dmax), 1, 0\\] for max degree node, connected to max degree, else (respectively) as test vector in courant fischer\n\n3.  Smallest Eigenvalue, undirected, unweighted, upper bound by max degree\n\n$$\n\\begin{aligned}\n\\lambda_n (A) \\leq -\\sqrt{k_{max}}\n\\end{aligned}\n$$ proof: use \\[sqrt(dmax), -1, 0\\] for max degree node, connected to max degree, else (respectively) as test vector in courant fischer.\n\n### Example Spectrums\n\nFirst we'll examine how all the adjacency matrices vary in terms of their eigenvalues.\n\n\n::: {.cell .fig-cap-location-bottom hash='matrix_cache/html/unnamed-chunk-3_5a451b42d2220ef699024c0692eecc9f'}\n\n```{.r .cell-code}\ng5_list <- read_file6(\"data/graph5c.g6\", type = \"adjacency\")\n\ng5_list |> enframe(name = \"gid\", value = \"adj\") |> \n  rowwise() |> \n  mutate(eig_values = list(zapsmall(eigen(adj)$values)),\n         gid = factor(gid),\n         max_eig = max(eig_values)) |>\n  mutate(gid_name = recode(gid,\n                           \"9\" = \"9 (line)\",\n                           \"1\" = \"1 (cross)\",\n                           \"21\" = \"21 (complete)\",\n                           \"7\" = \"7 (wakanda)\")) |> \n  dplyr::select(gid, gid_name, eig_values, max_eig) |> \n  unnest_longer(col = c(\"eig_values\")) |>\n  group_by(gid, gid_name, eig_values, max_eig) |> \n  summarize(\n    multiplicity = factor(n(), levels = 1:4, ordered = TRUE),\n    .groups = \"drop_last\") |> \n  ggplot(aes(x = fct_reorder(gid_name, max_eig), y = eig_values, color = multiplicity)) +\n  geom_point() +\n  scale_color_manual(values = colorRampPalette(colors = c(\"#69CAFF\", \"#9900FF\"), interpolate = \"spline\")(4)) +\n  labs(x = \"Graph Number\",\n       y = \"Eigenvalue\",\n       color = \"Multiplicity\") +\n  coord_cartesian(ylim = c(-4, 4)) +\n  theme_test() +\n  theme(panel.grid.major.y = element_line(color = \"gray90\"),\n        panel.border = element_blank(),\n        axis.line = element_line(color = \"black\"))\n```\n\n::: {.cell-output-display}\n![Eigenvalues of undirected, adjacency matrices. All matrices are connected 5 graphs. We note that there are both postive and negative eigenvalues unless the graph has no edges.](matrix_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n### Spectral Radius Bounds\n\n::: {.callout-note icon=\"false\"}\n#### Theorem 2.3: Adjacency Matrix Spectral Radius Bound [@hongSharpUpperBound2001]\n\n$$\n\\begin{aligned}\n\\rho(A) \\leq \\frac{d_{min} -1 + \\sqrt{(d_{min} + 1)^2 + 4(2m-nd_{min})}}{2}\n\\end{aligned}\n$$\n\n-   $d_{min}$ is minimum degree on the graph\n-   $n,m$ is number of nodes, edges in the graph\n-   equality is reached for regular graphs, or bi-degreed graphs of either $d_{min}$ or $n-1$\n\nMore simply, for a simply connected graph $d_{min} = 1$ the expression simplifies\n\n$$\n\\begin{align*}\n\\rho(A) \\leq \\sqrt{1 + 2m - n}\n\\end{align*}\n$$ {#eq-easy-hong-adj-spectral}\n\n-   equality reached for complete or star graph\n:::\n\n\n::: {.cell hash='matrix_cache/html/hong_upper_adj_spectral_d578ab001c2a33fc239e4e7c4a2c920c'}\n\n```{.r .cell-code}\nhong_upper_adj_spectral <- function(d_min, n, m, easy = FALSE) {\n  if (easy) return(sqrt(1 + 2*m - n))\n  (d_min - 1 + sqrt((d_min + 1)^2 + 4 * (2 * m - n * d_min))) / 2\n}\n```\n:::\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-5_be7a6dd6c0ab1d018600e5f1b30f0186'}\n\n```{.r .cell-code}\ng5_list <- read_file6(\"data/graph5c.g6\", type = \"igraph\")\n\nspectrum(g5_list[[5]], which = list(pos = \"LM\", howmany = 1))$values\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.135779\n```\n:::\n\n```{.r .cell-code}\neigen(as_adj(g5_list[[2]]))$values[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.847759\n```\n:::\n\n```{.r .cell-code}\ng5_hong_df <- tibble(g = g5_list) |> \n  rownames_to_column(\"g_id\") |> \n  rowwise() |> \n  mutate(min_deg = min(degree(g)),\n         n_edge = ecount(g),\n         n_vertex = vcount(g),\n         spectral_radius = eigen(as_adj(g))$values[1],\n         upper_spectral = hong_upper_adj_spectral(min_deg, n_vertex, n_edge),\n         easy_upper_spectral = hong_upper_adj_spectral(min_deg, n_vertex, n_edge, easy = TRUE)) |> \n  arrange(upper_spectral, easy_upper_spectral, spectral_radius)\n\ng5_hong_df |> ggplot(aes(factor(g_id, unique(g_id)), spectral_radius)) +\n  geom_point(aes(color = \"Spectral Radius\")) +\n  geom_line(aes(y = upper_spectral, group = 1, color = \"Hong Upper Bound\", linetype = \"Hong Upper Bound\")) +\n  geom_line(aes(y = easy_upper_spectral, group = 1, color = \"Hong Easy Upper Bound\", linetype = \"Hong Easy Upper Bound\")) +\n  guides(colour = guide_legend(override.aes = list(shape = c(26, 26, 19), linetype = c(1, 2, 0)))) +\n  scale_color_manual(\"\", values = c(\"red\", \"red\", \"black\")) +\n  scale_shape(guide = \"none\") + \n  scale_linetype(guide = \"none\") +\n  labs(x = \"graph\",\n       y = \"Adj. Spectral Radius\",\n       title = \"Hong Spectral Radius of Adjacency for all connected 5-graphs\")\n```\n\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## Laplacian\n\n### Example Spectrums\n\n::: panel-tabset\n#### Components\n\nIf there are 2 connected components, 2 of the eigenvalues will be 0.\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-6_db48c890e1938d0b6f192f27a92ad059'}\n\n```{.r .cell-code}\ng1 <- graph(~1-2-3-1-4-5-6-4)\nL1 <- laplacian_matrix(g1)\nplot(g1)\n```\n\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n```{.r .cell-code}\neigen(L1)$values |> zapsmall()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.561553 3.000000 3.000000 3.000000 0.438447 0.000000\n```\n:::\n\n```{.r .cell-code}\ng2 <- graph(~1-2-3-1, 4-5-6-4)\nplot(g2)\n```\n\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-6-2.png){width=672}\n:::\n\n```{.r .cell-code}\nL2 <- laplacian_matrix(g2)\neigen(L2)$values |> zapsmall()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3 3 3 0 0\n```\n:::\n:::\n\n\n#### Complete Graph\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-7_cb80265b679595f559baad5db07715d1'}\n\n```{.r .cell-code}\ng <- make_full_graph(5)\nL <- laplacian_matrix(g)\nplot(g)\n```\n\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\neigen(L)$values |> zapsmall()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 5 5 5 0\n```\n:::\n:::\n\n\n#### Star Graph\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-8_d33b484f067c62b478957f3ed5163494'}\n\n```{.r .cell-code}\ng <- make_star(5, mode = \"undirected\")\nL <- laplacian_matrix(g)\nplot(g)\n```\n\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code}\neigen(L)$values |> zapsmall()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 1 1 1 0\n```\n:::\n:::\n\n\n#### Bipartite Graph\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-9_38dca0d80f62128c79f3d25f97066623'}\n\n```{.r .cell-code}\ng <- make_full_bipartite_graph(5, 3)\nL <- laplacian_matrix(g, normalized = F)\nplot(g)\n```\n\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.r .cell-code}\neigen(L)$values |> zapsmall()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8 5 5 3 3 3 3 0\n```\n:::\n:::\n\n\n#### Path\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-10_6e055d63041750bb522fb1e355c8eeab'}\n\n```{.r .cell-code}\ng <- make_graph(~1-2-3-4-5-6-7-8-9-10)\nL <- laplacian_matrix(g, normalized = F)\nplot(g)\n```\n\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n```{.r .cell-code}\neigen(L)$values |> zapsmall()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 3.902113 3.618034 3.175571 2.618034 2.000000 1.381966 0.824429 0.381966\n [9] 0.097887 0.000000\n```\n:::\n:::\n\n:::\n\n\n```{mermaid}\n%%| include: false\n%%| eval: false\n%%| fig-width: 6\n\n%% works better outside of a tabset for some reason\nflowchart LR\n  a --- b\n  b --- c\n```\n\n\n### Spectral Radius Bounds\n\n#### Simple\n\nThere are 3 simple bounds on the Laplacian presented by [@andersonEigenvaluesLaplacianGraph1985],\n\n1.  number of nodes in graph\n\n$$ \\lambda_1(L) \\leq n$$\n\n-   equality reached on complete graph, for example.\n\n2.  max degree\n\n$$ \\lambda_1(L) \\leq 2d_{max}$$\n\n-   equality nears on a path graph.\n\n3.  maximal ends of an edge\n\n$$ \\lambda_1(L) \\leq \\max_{i\\sim j} w_i + w_j $$\n\n-   where maximum is over edges in graph, and $w_i + w_j$ is the sum of weights of that edge's endpoints.\n-   I believe this is true over any weighted, connected, undirected graph\n-   equality is reached when bipartite graph\n\n### Laplacian for Distributed Summation\n\n::: {.callout-note appearance=\"minimal\"}\n#### Source\n\nThis insight comes from [Sivan Toledo](https://www.tau.ac.il/~stoledo/Support/ex-distributed-summation.pdf), where he has a nice description of the problem.\n:::\n\nIf the eventual algorithm goal is to have the sum of the graph sitting on every node, the repeated application of a matrix multiplication should converge to the matrix of all ones $J$. The spectrum of $J$ is simply $n$ and the rest zeros. $\\frac{1}{n}J$ is special because it sets each node to have the mean, and the single non-zero eigenvalue is 1.\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-12_620ae92a9dd67265ff2243552b819351'}\n\n```{.r .cell-code}\neigen(matrix(rep(1/4, 16), nrow = 4))$values |> zapsmall()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0 0 0\n```\n:::\n:::\n\n\nSuppose the initial state of the graph $y$ is values at each of the $n$ nodes of the graph.\n\n$$\n\\begin{aligned}\nn(I - \\frac{1}{n}L)^ky\n\\end{aligned}\n$$\n\nAs $k$ increases, we'd expect that the matrix spectrum converges to match $J$, since $L$ has a zero eigenvalue, one eigen value limit is 1. And since the Laplacian has spectral radius upper bounded by number of nodes,\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-13_a3712cbe4a984204374ae606cc1c602a'}\n\n```{.r .cell-code}\nset.seed(1)\ng <- sample_gnp(10, .5)\nA <- g %>% as_adj()\nL <- Diagonal(x = rowSums(A)) - A\n```\n:::\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-14_437dd4eb7a1b1577ab818efa33b4ffb6'}\n\n```{.r .cell-code}\nJ <- Matrix(1, nrow = 10, ncol = 10)\nJ %*% cbind(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10 x 1 Matrix of class \"dgeMatrix\"\n      [,1]\n [1,]   55\n [2,]   55\n [3,]   55\n [4,]   55\n [5,]   55\n [6,]   55\n [7,]   55\n [8,]   55\n [9,]   55\n[10,]   55\n```\n:::\n:::\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-15_aa27e8e9b419f5c9572c64e3986aeeb2'}\n\n```{.r .cell-code}\nJe <- eigen(J)\nLn <- laplacian_matrix(g, normalized = TRUE)\neigen(Ln)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\neigen() decomposition\n$values\n [1] 1.647271e+00 1.467555e+00 1.450327e+00 1.166667e+00 1.084726e+00\n [6] 1.000000e+00 9.451136e-01 7.853920e-01 4.529494e-01 2.442491e-15\n\n$vectors\n             [,1]        [,2]         [,3]          [,4]        [,5]\n [1,] -0.16557306 -0.35884141  0.414024644  4.378811e-16 -0.41543869\n [2,]  0.01245928  0.32716246 -0.261033301  7.071068e-01 -0.26421090\n [3,]  0.07815309  0.07003764  0.522362456 -2.958733e-16  0.30735544\n [4,]  0.49476837 -0.29623231 -0.126497326  3.013764e-16 -0.34924549\n [5,] -0.26126348 -0.45016699 -0.226430018  3.655149e-16 -0.17830741\n [6,]  0.01453893 -0.34738481 -0.412927706 -6.383782e-16  0.64394097\n [7,]  0.29116939 -0.06983555  0.410643861 -1.133005e-16  0.11871973\n [8,]  0.39734608  0.39945650 -0.007375584 -5.551115e-17  0.08547476\n [9,]  0.01245928  0.32716246 -0.261033301 -7.071068e-01 -0.26421090\n[10,] -0.64049820  0.27700977  0.113930213 -2.030681e-18  0.05918033\n               [,6]        [,7]       [,8]        [,9]      [,10]\n [1,] -3.131423e-15  0.23529056  0.5901861  0.09578594 -0.2948839\n [2,] -3.906316e-15  0.22258023 -0.1102821  0.25044926 -0.3611576\n [3,] -6.324555e-01 -0.02451212 -0.2642891  0.25347743 -0.2948839\n [4,] -3.162278e-01  0.13949439 -0.2339562 -0.57753213 -0.1474420\n [5,]  6.578071e-15 -0.66595972 -0.2431392  0.18631243 -0.3296902\n [6,] -1.421198e-15  0.30002682  0.2257963 -0.02773400 -0.3900947\n [7,]  7.071068e-01  0.04045948 -0.3410158 -0.03156311 -0.3296902\n [8,]  6.679915e-15 -0.53861397  0.5160385 -0.17841799 -0.2948839\n [9,] -2.959103e-15  0.22258023 -0.1102821  0.25044926 -0.3611576\n[10,] -1.665335e-16  0.01531268 -0.1004178 -0.63187856 -0.2948839\n```\n:::\n\n```{.r .cell-code}\n# not correct\n# M <- diag(10) - L / (diag(L) + 1) # direct averaging of over all nodes ***\n# M <- diag(L) - L/2 # average across edges?\n\n# correct\nM <- diag(10) - L / 10\n\nmat_pow <- function(M, t = 10) {\n  if (t == 1) {return(M)}\n  return(M %*% mat_pow(M, t - 1))\n}\n# mat_pow(M, 100)\n\ny <- cbind(1:10)\nfor (i in 1:100) {\n  y <- M %*% y\n}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10 x 1 Matrix of class \"dgeMatrix\"\n          [,1]\n [1,] 5.499981\n [2,] 5.499980\n [3,] 5.499978\n [4,] 5.500109\n [5,] 5.499981\n [6,] 5.499988\n [7,] 5.499989\n [8,] 5.499992\n [9,] 5.499980\n[10,] 5.500024\n```\n:::\n:::\n\n\n### Normalized Laplacian\n\nThe primary reason for looking at the normalized laplacian is because it removes dependence on the number of nodes in the graph, which would change bounds. Rather, the eigenvalues of a normalized laplacian will range from $0 \\leq 2$, reaching 2 for bipartite graphs.\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-16_9105d8a7e3cdbd09fd36d677b2ec220d'}\n\n```{.r .cell-code}\nD <- 1 / sqrt(diag(L))\nNL <- Diagonal(x = D) %*% L %*% Diagonal(x = D)\nNL\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10 x 10 sparse Matrix of class \"dgCMatrix\"\n                                                                            \n [1,]  1.0000000 -0.2041241  .          .    .         -0.1889822  .        \n [2,] -0.2041241  1.0000000 -0.2041241  .   -0.1825742 -0.1543033 -0.1825742\n [3,]  .         -0.2041241  1.0000000  .   -0.2236068 -0.1889822  .        \n [4,]  .          .          .          1.0  .          .          .        \n [5,]  .         -0.1825742 -0.2236068  .    1.0000000  .         -0.2000000\n [6,] -0.1889822 -0.1543033 -0.1889822  .    .          1.0000000 -0.1690309\n [7,]  .         -0.1825742  .          .   -0.2000000 -0.1690309  1.0000000\n [8,] -0.2500000  .          .          .   -0.2236068 -0.1889822  .        \n [9,] -0.2041241 -0.1666667 -0.2041241  .   -0.1825742 -0.1543033 -0.1825742\n[10,]  .          .          .         -0.5  .         -0.1889822 -0.2236068\n                                      \n [1,] -0.2500000 -0.2041241  .        \n [2,]  .         -0.1666667  .        \n [3,]  .         -0.2041241  .        \n [4,]  .          .         -0.5000000\n [5,] -0.2236068 -0.1825742  .        \n [6,] -0.1889822 -0.1543033 -0.1889822\n [7,]  .         -0.1825742 -0.2236068\n [8,]  1.0000000  .         -0.2500000\n [9,]  .          1.0000000  .        \n[10,] -0.2500000  .          1.0000000\n```\n:::\n:::\n\n\n#### Example Spectrums of Normalized Laplacian\n\n::: panel-tabset\n#### Ring\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-17_d701989161d6780cc0f5ca0911470c0a'}\n\n```{.r .cell-code}\ng <- make_ring(5)\nplot(g)\n```\n\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n```{.r .cell-code}\nN <- laplacian_matrix(g, normalized = TRUE)\n# 1 - cos(2 * pi * 0:4 / 5) |> sort() # exact\neigen(N)$values |> zapsmall()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.809017 1.809017 0.690983 0.690983 0.000000\n```\n:::\n:::\n\n\n#### Path\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-18_edca6516ff3a56b7bef0f0a4e8207bcc'}\n\n```{.r .cell-code}\ng <- graph(~1-2-3-4-5)\nN <- laplacian_matrix(g, normalized = TRUE)\n# 1 - cos(pi * 0:4 / 4) |> sort() # exact\neigen(N)$values |> zapsmall()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.0000000 1.7071068 1.0000000 0.2928932 0.0000000\n```\n:::\n:::\n\n\n#### Complete\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-19_7c748e24cd559f5a46458ee5c433f3cc'}\n\n```{.r .cell-code}\ng <- make_full_graph(5)\nN <- laplacian_matrix(g, normalized = TRUE)\neigen(N)$values |> zapsmall() # n / n-1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.25 1.25 1.25 1.25 0.00\n```\n:::\n:::\n\n\n#### Bipartite\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-20_5b8e82f3716b5635a5adf5315025f92b'}\n\n```{.r .cell-code}\ng <- make_full_bipartite_graph(6, 4)\nN <- laplacian_matrix(g, normalized = TRUE)\neigen(N)$values |> zapsmall() # 0, 1 (n + m - 2), 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 2 1 1 1 1 1 1 1 1 0\n```\n:::\n:::\n\n:::\n\n### Fiedler Bounds (normalized Laplacian)\n\nFiedler Eigenvalue is the smallest non-zero eigenvalue.\n\n#### Simple\n\nFor k-regular graph, and diameter \\> 4, we have\n\n$$\n\\begin{aligned}\n\\limsup \\lambda_{n-1} \\leq 1 - 2\\frac{\\sqrt{k-1}}{k}\n\\end{aligned}\n$$\n\n-   equality is reached for ramanujan graphs\n-   note that the conditions exclude bipartite graphs\n-   the fact that it's \"lim sup\" makes this quite useless, because it's asymptotically toward infinity\". In fact, for some regular 4 graphs, 14 node, diameter 5 graphs, the Fiedler value is still well above this bound.\n\nRather, a more general (and useful upper bound):\n\n::: {.callout-note icon=\"false\"}\n#### Lemma 1.14: Fiedler Upper Bound (dia $\\geq$ 4) [@chungSpectralGraphTheory1997]\n\nLet $G$ be a graph with diameter $D \\geq 4$, and let $k$ denote the maximum degree of $G$. Then,\n\n$$\n\\begin{aligned}\n\\lambda_{n-1} \\leq 1 - 2\\frac{\\sqrt{k-1}}{k}\\left(1 - \\frac{2}{D}\\right) + \\frac{2}{D}\n\\end{aligned}\n$$\n\n::: {.callout-note icon=\"false\" collapse=\"true\"}\n#### Proof\n\nBy contracting weighted graphs, and using Rayleigh quotient to upper bound.\n:::\n:::\n\nNote that the original reference [@nilliSecondEigenvalueGraph1991] , studies this problem for non-standardized Laplacian.\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-21_7934c10da8913d66582a6da94c978cad'}\n\n```{.r .cell-code}\nupper_fiedler_nilli <- function(k, D) {\n  if (D < 4) abort(\"upper bound only valid when diameter greater than 4\")\n  return(1 - 2 * sqrt(k -1) / k * (1 - 2 / D) + 2 / D)\n}\n```\n:::\n\n\n\n\n\n\nLet's generate all permutations of connected 8 graphs, and pick out those with diameter greater than 4. All graph generation is done with the program `geng` and filtered with `pickg` [@mckayPracticalGraphIsomorphism2013].\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-24_a29e43d091d1ba0efcfa72ae93bd7bff'}\n\n```{.r .cell-code}\ng8_dia4plus_list <- read_file6(\"data/graph8cdia4p.g6\", type = \"igraph\")\n\ng8_dia4plus_df <- tibble(g = g8_dia4plus_list) |> \n  rownames_to_column(\"g_id\") |> \n  rowwise() |> \n  mutate(fiedler = net_fiedler(g, normalize = T),\n         k = max(degree(g)),\n         D = diameter(g),\n         upper_fiedler = upper_fiedler_nilli(k, D)) |> \n  arrange(desc(upper_fiedler), desc(fiedler))\n  \ng8_dia4plus_df |> \n  ggplot(aes(x = factor(g_id, levels = unique(g_id)),\n             y = fiedler, color = \"Fiedler Value\")) +\n  geom_point(size = .5, alpha = .7) +\n  geom_line(aes(y = upper_fiedler, group = upper_fiedler, color = \"Upper Bound\")) +\n  labs(color = \"Color\",\n       title = \"Nilli Bound on Fiedler Value for connected-8 Graphs\",\n       x = \"Unique Graph Combinations\",\n       y = \"Fiedler Value\") +\n  scale_color_manual(values = c(\"black\", \"red\")) +\n  scale_x_discrete(breaks = NULL, labels = NULL) + \n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-25_f5daa12f99d47090284b3f5ef3a1ab4f'}\n\n```{.r .cell-code}\n# files with regular, diameter larger than 4\n# These are all 4 regular graphs, connected, 13/14 nodes, d\nreg4_dia4plus_files <- c(\"data/reg4c13dia4.g6\", \"data/reg4c13dia5.g6\", \"data/reg4c14dia4.g6\", \"data/reg4c14dia5.g6\") \nreg4_dia4plus_list <- reg4_dia4plus_files |> \n  map(read_file6, type = \"igraph\")\n\nreg4_dia4plus_df <- tibble(g = reg4_dia4plus_list, path = reg4_dia4plus_files)  |> \n  unnest_longer(g, indices_include = TRUE, indices_to = \"graph_id\") |> \n  rowwise() |> \n  mutate(match = list(str_match(path, \"data/reg4c(\\\\d*)dia(\\\\d*)\")),\n         nodes = match[2],\n         dia = match[3],\n         k = 4,\n         fiedler = net_fiedler(g, normalized = T),\n         upper_fiedler = 1 - 2*sqrt(4-1) / 4) |> \n  select(-c(match, path)) |> arrange(desc(dia), nodes)\n\nreg4_dia4plus_df <- reg4_dia4plus_df |> mutate(dia = as.numeric(dia),\n                           islower = upper_fiedler > fiedler,\n                           other_upper = 1 - 2 * sqrt(4 - 1)/4 * (1 - 2 / dia) + 2/dia,\n                           other_islower = other_upper > fiedler) |> \n  arrange(islower, other_islower, desc(dia))\n\n# among regular graphs, 13-14 nodes, 4+ diameter\nreg4_dia4plus_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4,271 × 10\n# Rowwise: \n   g        graph_id nodes   dia     k fiedler upper_f…¹ islower other…² other…³\n   <list>      <int> <chr> <dbl> <dbl>   <dbl>     <dbl> <lgl>     <dbl> <lgl>  \n 1 <igraph>        1 13        4     4   0.203     0.134 FALSE      1.07 TRUE   \n 2 <igraph>        2 13        4     4   0.250     0.134 FALSE      1.07 TRUE   \n 3 <igraph>        3 13        4     4   0.207     0.134 FALSE      1.07 TRUE   \n 4 <igraph>        4 13        4     4   0.205     0.134 FALSE      1.07 TRUE   \n 5 <igraph>        5 13        4     4   0.204     0.134 FALSE      1.07 TRUE   \n 6 <igraph>        6 13        4     4   0.257     0.134 FALSE      1.07 TRUE   \n 7 <igraph>        7 13        4     4   0.255     0.134 FALSE      1.07 TRUE   \n 8 <igraph>        8 13        4     4   0.257     0.134 FALSE      1.07 TRUE   \n 9 <igraph>        9 13        4     4   0.188     0.134 FALSE      1.07 TRUE   \n10 <igraph>       10 13        4     4   0.192     0.134 FALSE      1.07 TRUE   \n# … with 4,261 more rows, and abbreviated variable names ¹​upper_fiedler,\n#   ²​other_upper, ³​other_islower\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n\n```{.r .cell-code}\nreg4_dia4plus_df |> unite(col = \"g_uid\", !!!c(\"nodes\", \"dia\", \"graph_id\"), remove = FALSE) |>\n  ggplot(aes(fct_reorder2(g_uid, fiedler, dia, .desc = T), fiedler)) +\n  geom_point() + \n  geom_point(aes(y = upper_fiedler), color = \"red\") +\n  geom_point(aes(y = other_upper), color = \"red\")\n```\n\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# reg4_dia4plus_df\n# reg4_dia4plus_df # well... they are all lower bounded? if it's an infinite family of regular graphs... it should get closer right? b/c it's lim sup?\n```\n:::\n\n\n#### By Volume (global)\n\nA loose lower bound for the smallest non-trivial eigenvalue [@chungSpectralGraphTheory1997 pp. 7]:\n\n$$\n\\begin{aligned}\n\\lambda_{n-1} \\geq \\frac{1}{D\\operatorname{vol}(G)}\n\\end{aligned}\n$$ where $D$ is the diameter of the graph, and volume of the graph is the sum of degrees for each node.\n\n::: {.callout-warning appearance=\"minimal\"}\n#### Definition of Volume\n\nNote that @chungSpectralGraphTheory1997 uses the definition $\\operatorname{vol}(G) = \\sum_{x\\in S}d_x$ where $d_x$ is the degree of vertex $x$. Other references use $\\operatorname{vol}(G) = |G|$ which is the number of nodes, or giving each node weight 1.\n:::\n\nLet's find the Fiedler value of every graph of size 5 and graph them against the bound,\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-26_0305bb180507ee8fcc30d55545711d56'}\n\n```{.r .cell-code}\ng5_list <- read_file6(\"data/graph5c.g6\", type = \"igraph\")\n\n# fiedler values\nfiedler5 <- lapply(g5_list, function(g) {\n  vol <- sum(degree(g)) # conservative\n  # vol <- vcount(g)\n  M <- laplacian_matrix(g, normalized = TRUE)\n  dia <- diameter(g, directed = FALSE)\n  list(g = list(g),\n       fiedler = eigen(M)$values[4],\n       vol = vol,\n       dia = dia)\n})\n\ngraph_fiedler <- tibble(gg = fiedler5) |> unnest_wider(gg) |> unnest(cols = c(g)) |> \n  mutate(bound = 1/ (dia * vol),\n         diff = fiedler - bound) |> \n  arrange(diff)\n\n\n# calculate the lower bound.\nfiedler_bound_line <- tibble(dia = rep(list(seq(1, 4, .1)), 3), vol = c(5, 10, 20)) |> rowwise() |> \n  mutate(bound = list(1 / vol / dia)) |> \n  unnest_longer(col = c(dia, bound))\n\n\n# The bound is generally quite bad for graphs \ngraph_fiedler |> ggplot(aes(dia, fiedler, color = vol)) +\n  geom_line(data = fiedler_bound_line, mapping = aes(dia, bound, color = vol, group = vol)) +\n  geom_point() +\n  labs(title = \"Simple Fiedler Bound\")\n```\n\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\nEven using the vertex count definition for volume (less conservative), the bound is quite low for most of the Fiedler values.\n\n#### By Cheeger's (Sparsest Cut)\n\nCheeger's constant is loosely defined in english, as the minimal ratio, of cost of cutting edges, to the size of sets it cuts off. That is, a \"dumbbell\" shape graph, where large vertex sets are on both side, and only cutting 1 edge in the middle would have a very very low cheeger constant.\n\n$$\n\\begin{aligned}\nh_G &= \\min_S \\frac{|\\delta S|}{\\min \\{|S|,|\\bar S| \\}} \\\\&= \\frac{\\text{cutting edges cost}}{\\text{vertex set volume}}\n\\end{aligned}\n$$\n\nCalculating Cheeger's constant is an [NP-Hard problem](https://cstheory.stackexchange.com/questions/8615/computing-the-cheeger-constant-feasible-for-which-classes), meaning that the problem is likely non-polynomial for solution and checking.\n\nThe bounds on Fiedler's value, with cheegers constants have the form,\n\n$$\n\\begin{aligned}\n\\frac{h_G^2}{2d_{max}} \\leq \\lambda_{n-1}  \\leq 2h_G \n\\end{aligned}\n$$\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-27_2f53705931c8526d74aa0051eeed05d7'}\n\n```{.r .cell-code}\n# graph_boundary_edges <- function(g, vs) {\n#   if(!inherits(g, \"igraph\")) {\n#     abort(\"`g` must be of class `igraph`\")\n#   }\n#   inc_edges <- igraph::incident_edges(g, vs)\n#   purrr::reduce()\n# }\n\n# graph_interior_edges <- function(g, vs) {\n#   if(!inherits(g, \"igraph\")) {\n#     abort(\"`g` must be of class `igraph`\")\n#   }\n#   inc_edges <- igraph:incident_edges(g, vs)\n# }\n\n\n# forget the functions... just do on matrices\n```\n:::\n\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-29_0258a41bbe3fcebd7e2aeaf389529b75'}\n\n```{.r .cell-code}\n#TODO: implemented assuming undirected graph, generalize?\ncheeger <- function(A, S) {\n  # calculate vertex boundary by taking neighbors minus initial set\n  adj_vec_set <- A[S,, drop = F] |> colSums()\n  ego1 <- which(adj_vec_set > 0)\n  dS <- setdiff(ego1, S) # vertex boundary\n  \n  # calculate edge boundary by subsetting matrix from S to !S\n  bridge_matrix <- A[S, dS, drop = F]\n  \n  bridge_edges <- bridge_matrix |> \n    as(\"lgCMatrix\") |> # also assumes unweighted here when converting to logical\n    which(arr.ind = T) \n  bridge_edges[,\"row\"] <- S[bridge_edges[,\"row\"]] # convert indices\n  bridge_edges[,\"col\"] <- dS[bridge_edges[,\"col\"]]\n  vol_dS <- sum(bridge_matrix)\n  min_vol_S <- min(length(S), nrow(A) - length(S)) # use length as volume metric\n  return(vol_dS / min_vol_S)\n}\n\n# generate subsets for each graph\nall_comb <- mapply(function(x) combn(5, x, simplify = F), 1:5)\nall_comb_df <- tibble(elem = all_comb) |>\n  unnest_longer(elem)\n\ngraph_df <- g5_list |> lapply(as_adj) |>\n  tibble(A = _) |> rownames_to_column(var = \"id\") |> \n  mutate(id = as.numeric(id))\n\ncheeger_df <- full_join(graph_df, all_comb_df, by = character()) |> rowwise() |> \n  mutate(cheeger_values = cheeger(A, elem))\n\ncheeger_constant_df <- cheeger_df |> filter(cheeger_values > 0) |>  group_by(id) |> arrange(id, cheeger_values) |> slice(1) |> ungroup()\n\n# cheeger_constant_df |> slice(2) |> unlist()\n\nfiedler_value_df <- tibble(gg = fiedler5) |> unnest_wider(gg) |> unnest(cols = c(g)) |> \n  rownames_to_column(var = \"id\") |> \n  rowwise() |> \n  mutate(id = as.numeric(id),\n         max_deg = max(degree(g))) |> \n  select(id, fiedler, dia, vol, max_deg) |> \n  ungroup()\n\n\ncheeger_fiedler_df <- cheeger_constant_df |> select(id, elem, cheeger_values) |> left_join(fiedler_value_df, by = \"id\") |> \n  mutate(upper_cheeger = cheeger_values * 2,\n         lower_cheeger = cheeger_values^2 / 2/ max_deg) # dividing by max deg\n# cheeger_fiedler_df |> mutate(inbound = fiedler > lower_cheeger & fiedler < upper_cheeger)\n\ncheeger_fiedler_df |>\n  ggplot() +\n  geom_point(aes(id, lower_cheeger), color = \"red\") +\n  geom_point(aes(id, fiedler, color = vol)) +\n  geom_point(aes(id, upper_cheeger), color = \"red\") +\n  labs(y = \"Eigenvalue\",\n       x = \"Graph ID\",\n       title = \"\")\n```\n\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# many variations of cheeger's unfortunately\n# seems incorrect for\n```\n:::\n\n\n### Laplacian decomposition as incidence matrix\n\nIf we define an incidence matrix as a $|V| \\times |E|$ matrix, in which each column has a 1 and -1 for in positions the edge connects the vertices,\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-30_e30a503c14aaf6274ec53959b93ebcbc'}\n\n```{.r .cell-code}\n# ve_incidence <- function(g) {\n#   stopifnot(class(g) == \"igraph\")\n#   g %>% get.adjedgelist() %>% map_dbl(~-onehot(.x, n = ecount(g)))\n# }\n\n\nonehot <- function(x, n = max(x)) {\n  y <- vector(mode = \"numeric\",length = n)\n  y[x] <- 1\n  return(y)\n}\n\n\n# edge list\nve_incidence_matrix <- function(g) {\n  stopifnot(class(g) == \"igraph\")\n  onehot_edge <- function(x, n = max(x)) {\n    y <- vector(mode = \"numeric\",length = n)\n    y[x * sign(x)] <- sign(x)\n    return(y)\n  }\n  g_el <- get.edgelist(g) \n  g_el[,2] <- -g_el[,2]\n  g_el %>% apply(1, onehot_edge, n = vcount(g))\n}\n\nset.seed(1)\ng <- sample_gnp(10, .5)\nA <- g %>% as_adj()\nL <- Diagonal(x = rowSums(A)) - A\nB <- ve_incidence_matrix(g) # incidence matrix\n```\n:::\n\n\nOur incidence matrix $B$ looks like\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-31_471e9454035916848801f658e3d44c28'}\n::: {.cell-output-display}\n$$B = \\begin{bmatrix} 1 &0 &0 &0 &1 &0 &0 &0 &0 &0 &1 &0 &0 &1 &0 &0 &0 &0 &0 &0 &0 &0 &0 \\\\-1 &1 &1 &0 &0 &1 &0 &1 &0 &0 &0 &0 &0 &0 &1 &0 &0 &0 &0 &0 &0 &0 &0 \\\\0 &-1 &0 &1 &0 &0 &1 &0 &0 &0 &0 &0 &0 &0 &0 &1 &0 &0 &0 &0 &0 &0 &0 \\\\0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &1 &0 &0 &0 \\\\0 &0 &-1 &-1 &0 &0 &0 &0 &1 &0 &0 &1 &0 &0 &0 &0 &1 &0 &0 &0 &0 &0 &0 \\\\0 &0 &0 &0 &-1 &-1 &-1 &0 &0 &1 &0 &0 &1 &0 &0 &0 &0 &1 &0 &0 &1 &0 &0 \\\\0 &0 &0 &0 &0 &0 &0 &-1 &-1 &-1 &0 &0 &0 &0 &0 &0 &0 &0 &1 &0 &0 &1 &0 \\\\0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &-1 &-1 &-1 &0 &0 &0 &0 &0 &0 &0 &0 &0 &1 \\\\0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &-1 &-1 &-1 &-1 &-1 &-1 &0 &0 &0 &0 \\\\0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &0 &-1 &-1 &-1 &-1 \\\\ \\end{bmatrix}$$\n:::\n:::\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-32_6d4890d01eeb68056026456ad973bba2'}\n::: {.cell-output-display}\n$$L= \\begin{bmatrix} 4 &-1 &0 &0 &0 &-1 &0 &-1 &-1 &0 \\\\-1 &6 &-1 &0 &-1 &-1 &-1 &0 &-1 &0 \\\\0 &-1 &4 &0 &-1 &-1 &0 &0 &-1 &0 \\\\0 &0 &0 &1 &0 &0 &0 &0 &0 &-1 \\\\0 &-1 &-1 &0 &5 &0 &-1 &-1 &-1 &0 \\\\-1 &-1 &-1 &0 &0 &7 &-1 &-1 &-1 &-1 \\\\0 &-1 &0 &0 &-1 &-1 &5 &0 &-1 &-1 \\\\-1 &0 &0 &0 &-1 &-1 &0 &4 &0 &-1 \\\\-1 &-1 &-1 &0 &-1 &-1 &-1 &0 &6 &0 \\\\0 &0 &0 &-1 &0 &-1 &-1 &-1 &0 &4 \\\\ \\end{bmatrix}$$\n:::\n:::\n\n\nJust to see the sparsity pattern of B, (we try spam's display routine)\n\n\n::: {.cell hash='matrix_cache/html/unnamed-chunk-33_67bd765b0ff50bbf3768cc6b8d38b60f'}\n::: {.cell-output-display}\n![](matrix_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n### Laplacian Stochastic Matrix\n\n$I - D^{\\dagger}A$\n\n## Stochastic Matrices\n\nmatrices in which each matrix row sums to 1.\n\n## Matrix Norms\n\nThis section aims to quantify and give intuition behind the following matrix norms.\n\n-   spectral\n-   frobenius\n-   $L^n$\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}