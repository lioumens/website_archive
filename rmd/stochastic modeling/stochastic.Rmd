---
title: "Stochastic Modeling"
author: "Michael Liou"
date: "3/18/2022"
output: 
  html_document:
    code_folding: show
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```


# Brownian Motion

Brownian motion is a formalized continuous guassian step with variance proportional to the time step taken. Wiener process is sometimes used to describe the same thing.

# Simulating Stochastic Differential Equations

It seems like in R there are packages

* Sim.DiffProc

## Sim.DiffProc

Following the [package vignette](https://cran.r-project.org/web/packages/Sim.DiffProc/vignettes/snssde.html)

- `rsde1d` - random deviates from a sde object
- `dsde1d()` - approximate density from sde object
- `snssde2d()` - simulates 2d sde

We simulate from the example

$$
\begin{aligned}
dX = \frac{1}{2}\theta^2Xdt + \theta X dW
\end{aligned}
$$

Solving this for the steady state mean, then we get

$$
\begin{aligned}
E[X| t= 1, x_0 = 10, \theta = .5] = \exp{\left(\frac{1}{2}\theta^2t\right)}
\end{aligned}
$$

```{r}
library(sde)
library(Sim.DiffProc)
set.seed(1234, kind = "L'Ecuyer-CMRG")
theta <- .5
f <- expression((.5*theta^2*x))
g <- expression(theta*x)
mod1 <- snssde1d(drift = f, 
                 diffusion = g, # for the random gaussian portion
                 x0=10, # initial conditions
                 t0=0,
                 T = 5,
                 M = 1000, # number of sample solutions to simulate
                 type = "ito", # type of integral
                 method = "euler") # method

mod2 <- snssde1d(drift = f, diffusion = g, x0=10, M = 1000, type = "str")

# many summary and confidence intervals.
summary(mod1, at = .3) # by monte carlo of fitting the stochastic paths of the pandemic

summary(mod1)
```

```{r}
# sample from the conditional distribution, conditional on the initial value.
rsde1d(mod1, at = 1)
mu1 <- log(10); sigma1= sqrt(theta^2)
mu2 <- log(10) - .5*theta^2; sigma2= sqrt(theta^2)

# ito's integral
appdensI <- dsde1d(mod1, at = 1) # conditional density estimation at particular time
# strat integral
appdensS <- dsde1d(mod2, at = 1)
plot(appdensI, dens = function(x) dlnorm(x, meanlog = mu1, sdlog = sigma1))
plot(appdensS, dens = function(x) dlnorm(x, meanlog = mu2, sdlog = sigma2))
```


```{r}
plot(mod1) # show the plot values
lines(time(mod1),apply(mod1$X,1,mean),col=2,lwd=2)
lines(time(mod1),apply(mod1$X,1,bconfint,level=0.95)[1,],col=4,lwd=2)
lines(time(mod1),apply(mod1$X,1,bconfint,level=0.95)[2,],col=4,lwd=2)
legend("topleft",c("mean path",paste("bound of", 95,"% confidence")),inset = .01,col=c(2,4),lwd=2,cex=0.8)
```

In two dimensions, vector of drift and diffusion

$$
\begin{aligned}
dX = -\frac{1}{\mu} Xdt + \sqrt{\sigma} dW, \quad X_0 = x_0
\end{aligned}
$$

```{r}
x0=5;y0=0
mu=3;sigma=0.5
fx <- expression(-(x/mu),x)  
gx <- expression(sqrt(sigma),0)
mod2d <- snssde2d(drift=fx,diffusion=gx,Dt=0.01,M=1000,x0=c(x0,y0),method="smilstein")
mod2d
```

```{r}
summary(mod2d, at = 10)
```

```{r}
## in time
plot(mod2d)
## in plane (O,X,Y)
plot2d(mod2d,type="n") 
points2d(mod2d,col=rgb(0,100,0,50,maxColorValue=255), pch=16)
```

# Guassian Markov Random Field

GMRF is a generalization of the markov chians. I want to know what data actually looks like when simulated from a GMRF. We start with a line graph, which is just a standard random walk

## Random Walk

```{r}
n <- 20 # 20 obs
N <- 100 # nodes


#' Random Walk
#'
#' @param N number of nodes
#'
#' @return
#' @export
#'
#' @examples
randomwalk <- function(nodes = 10, y0 = 0, drift = 0, stddev = 1) {
  y0 + cumsum(rnorm(nodes, mean = drift, sd = stddev))
}

set.seed(1)
rw_mat <- replicate(1000,
          randomwalk(10)) # 6 rows, 1000 samples

rw_cov <- rw_mat %>% t() %>% cov() 
rw_prec <- rw_cov %>% solve()
image(rw_prec)

```

```{r}
# can try to use glasso to estimate sparse patterns in the covariance matrix
rw_glasso <- glasso(rw_cov, rho = .02, nobs = 1000)

rw_glassopath <- glassopath(rw_cov, rholist = seq(.01, .40, .01))

rw_glassopath$wi[,,6]

apply(rw_glassopath$wi, 3, as_function(~sum(.x != 0))) # why does the number of elements increase then decrease? behavior is curious
```

```{r}
set.seed(1)
gaus <- matrix(rnorm(50*20), ncol = 20)
gaus_cov <- var(gaus)
gaus_prec <- gaus_cov %>% solve()
gaus_prec %>% Matrix() %>% image() # has a diagonal structure

gaus_glasso <- glasso(gaus_cov, rho = .03, nobs = 50)

gaus_glassopath <- glassopath(gaus_cov, rho = seq(.01, .7, .01))

# count number of non-zero entries
apply(gaus_glassopath$wi, 3, as_function(~sum(.x != 0)))
gaus_glassopath$wi[,,60] %>% image() # sparsity pattern is correct but not the scale...
```


Sampling from multivariate normal distribution, sparse precision matrix, we use `sparseMVN`

```{r}
library(reshape2)

rw_dat <- rw_mat %>% melt(c("node","obs"))

rw_mat %>% t() %>% cov() # sample covariance

rw_dat %>% ggplot(aes(node, value)) +
  geom_point()

# estimating an unstructred covariance matrix...

rw_gls <- gls(value~1,  data = rw_dat,
          weights = varIdent(form = ~1 | node))


attr(rw_gls$modelStruct$varStruct, "weights")
class(rw_gls$modelStruct$varStruct)
nlme:::print.varFunc

coef(rw_gls$modelStruct$varStruct, unconstrained = FALSE, allCoef = TRUE)^2
nlme:::coef.varIdent


vignette(package = "sandwich")



getVarCov(rw_gls)
getVarCov(rw_gls, individual = 4)

rw_cs_cov <- corMatrix(Initialize(corCompSymm(value = .3, form = ~1 | obs), rw_dat))

rw_cs_cov %>% length()
```



=======
# Gamblers Ruin

The random walk we're simulating is a symmetric random walk


```{r echo = FALSE}
# parameterization
b <- 20 # upper bound
a <- 0 # lower bound
k <- 1 # initial state
p <- .5 # probability of increase

# random walk simulation for hitting times
rw_sim <- function(a, b, p, k, return_path = FALSE){
  t <- 0 
  ks <- NULL
  if (return_path) {
    ks <- c(k)
  }
  while(k < b & k > a) {
    k <- ifelse(rbinom(1, 1, p) == 1, k + 1, k - 1)
    ks <- c(ks, k)
    t <- t + 1
  }
  if (return_path) return(ks)
  return(t) # hitting time
}
```


```{r}
set.seed(20)
k <- 10
rw <- rw_sim(a, b, p, k, return_path = TRUE)

qplot(0:(length(rw) - 1), rw, geom = "line", xlab = "time", ylab = "state", linetype = "random walk path") + 
  geom_hline(yintercept = b, color = "tomato1") + 
  geom_hline(yintercept = a, color = "tomato1") +
  annotate("point", x = 0, y = 10, size = 2, color = "lightblue") +
  annotate("label", label = "k - initial state", x = 3, y = 9, fill = "lightblue", size = 2) +
  annotate("point", x = 44, y = 0, size = 2, color = "lightblue") +
  annotate("label", label = "T - hitting time", x = 41, y = 1, fill = "lightblue", size = 2) +
  scale_linetype_manual(values = c(3)) + 
  labs(linetype = "",
       title = "Hitting Times of Random Walk") + 
  lims(y = c(a, b)) + 
  theme_minimal() + 
  theme(legend.position = "bottom")
  
```

By theory, for the symmetric random walk, (see Durrett)

$$
\begin{aligned}
E[T|X_0 = k] = (k - a)(b - k)
\end{aligned}
$$

```{r}
hitting_times <- replicate(10000,
                           rw_sim(a,b,p, k))
mean(hitting_times)
```

# Brownian Motion

Brownian motion is a formalized continuous gaussian step with variance proportional to the time step taken. Wiener process is sometimes used to describe the same thing.


# Simulating Stochastic Differential Equations

It seems like in R there are packages

* Sim.DiffProc

## Sim.DiffProc

Following the [package vignette](https://cran.r-project.org/web/packages/Sim.DiffProc/vignettes/snssde.html)

- `rsde1d` - random deviates from a sde object
- `dsde1d()` - approximate density from sde object
- `snssde2d()` - simulates 2d sde

We simulate from the example

$$
\begin{aligned}
dX = \frac{1}{2}\theta^2Xdt + \theta X dW
\end{aligned}
$$

Solving this for the steady state mean, then we get

$$
\begin{aligned}
E[X| t= 1, x_0 = 10, \theta = .5] = \exp{\left(\frac{1}{2}\theta^2t\right)}
\end{aligned}
$$

```{r}
library(sde)
library(Sim.DiffProc)
set.seed(1234, kind = "L'Ecuyer-CMRG")
theta <- .5
f <- expression((.5*theta^2*x))
g <- expression(theta*x)
mod1 <- snssde1d(drift = f, 
                 diffusion = g, # for the random gaussian portion
                 x0=10, # initial conditions
                 t0=0,
                 T = 5,
                 M = 1000, # number of sample solutions to simulate
                 type = "ito", # type of integral
                 method = "euler") # method

mod2 <- snssde1d(drift = f, diffusion = g, x0=10, M = 1000, type = "str")

# many summary and confidence intervals.
summary(mod1, at = .3) # by monte carlo of fitting the stochastic paths of the pandemic

summary(mod1)
```

```{r}
# sample from the conditional distribution, conditional on the initial value.
rsde1d(mod1, at = 1)
mu1 <- log(10); sigma1= sqrt(theta^2)
mu2 <- log(10) - .5*theta^2; sigma2= sqrt(theta^2)

# ito's integral
appdensI <- dsde1d(mod1, at = 1) # conditional density estimation at particular time
# strat integral
appdensS <- dsde1d(mod2, at = 1)
plot(appdensI, dens = function(x) dlnorm(x, meanlog = mu1, sdlog = sigma1))
plot(appdensS, dens = function(x) dlnorm(x, meanlog = mu2, sdlog = sigma2))
```


```{r}
plot(mod1) # show the plot values
lines(time(mod1),apply(mod1$X,1,mean),col=2,lwd=2)
lines(time(mod1),apply(mod1$X,1,bconfint,level=0.95)[1,],col=4,lwd=2)
lines(time(mod1),apply(mod1$X,1,bconfint,level=0.95)[2,],col=4,lwd=2)
legend("topleft",c("mean path",paste("bound of", 95,"% confidence")),inset = .01,col=c(2,4),lwd=2,cex=0.8)
```

In two dimensions, vector of drift and diffusion

$$
\begin{aligned}
dX = -\frac{1}{\mu} Xdt + \sqrt{\sigma} dW, \quad X_0 = x_0
\end{aligned}
$$

```{r}
x0=5;y0=0
mu=3;sigma=0.5
fx <- expression(-(x/mu),x)  
gx <- expression(sqrt(sigma),0)
mod2d <- snssde2d(drift=fx,diffusion=gx,Dt=0.01,M=1000,x0=c(x0,y0),method="smilstein")
mod2d
```

```{r}
summary(mod2d, at = 10)
```

```{r}
## in time
plot(mod2d)
## in plane (O,X,Y)
plot2d(mod2d,type="n") 
points2d(mod2d,col=rgb(0,100,0,50,maxColorValue=255), pch=16)
```

# Guassian Markov Random Field

GMRF is a generalization of the markov chians. I want to know what data actually looks like when simulated from a GMRF. We start with a line graph, which is just a standard random walk

## Random Walk

```{r}
n <- 20 # 20 obs
N <- 100 # nodes


#' Random Walk
#'
#' @param N number of nodes
#'
#' @return
#' @export
#'
#' @examples
randomwalk <- function(nodes = 10, y0 = 0, drift = 0, stddev = 1) {
  y0 + cumsum(rnorm(nodes, mean = drift, sd = stddev))
}

set.seed(1)
rw_mat <- replicate(1000,
          randomwalk(10)) # 6 rows, 1000 samples

rw_cov <- rw_mat %>% t() %>% cov() 
rw_prec <- rw_cov %>% solve()
image(rw_prec)

```

```{r}
# can try to use glasso to estimate sparse patterns in the covariance matrix
rw_glasso <- glasso(rw_cov, rho = .02, nobs = 1000)

rw_glassopath <- glassopath(rw_cov, rholist = seq(.01, .40, .01))

rw_glassopath$wi[,,6]

apply(rw_glassopath$wi, 3, as_function(~sum(.x != 0))) # why does the number of elements increase then decrease? behavior is curious
```

```{r}
set.seed(1)
gaus <- matrix(rnorm(50*20), ncol = 20)
gaus_cov <- var(gaus)
gaus_prec <- gaus_cov %>% solve()
gaus_prec %>% Matrix() %>% image() # has a diagonal structure

gaus_glasso <- glasso(gaus_cov, rho = .03, nobs = 50)

gaus_glassopath <- glassopath(gaus_cov, rho = seq(.01, .7, .01))

# count number of non-zero entries
apply(gaus_glassopath$wi, 3, as_function(~sum(.x != 0)))
gaus_glassopath$wi[,,60] %>% image() # sparsity pattern is correct but not the scale...
```


Sampling from multivariate normal distribution, sparse precision matrix, we use `sparseMVN`

```{r}
library(reshape2)

rw_dat <- rw_mat %>% melt(c("node","obs"))

rw_mat %>% t() %>% cov() # sample covariance

rw_dat %>% ggplot(aes(node, value)) +
  geom_point()

# estimating an unstructred covariance matrix...

rw_gls <- gls(value~1,  data = rw_dat,
          weights = varIdent(form = ~1 | node))


attr(rw_gls$modelStruct$varStruct, "weights")
class(rw_gls$modelStruct$varStruct)
nlme:::print.varFunc

coef(rw_gls$modelStruct$varStruct, unconstrained = FALSE, allCoef = TRUE)^2
nlme:::coef.varIdent


vignette(package = "sandwich")



getVarCov(rw_gls)
getVarCov(rw_gls, individual = 4)

rw_cs_cov <- corMatrix(Initialize(corCompSymm(value = .3, form = ~1 | obs), rw_dat))

rw_cs_cov %>% length()
```



